# Вступление

<VueSchoolLink
  href="https://vueschool.io/lessons/introduction-to-pinia"
  title="Начните работу с Pinia"
/>

Pinia [началась](https://github.com/vuejs/pinia/commit/06aeef54e2cad66696063c62829dac74e15fd19e) как эксперимент по переработке того, как может выглядеть хранилище состояния для Vue с [Composition API](https://github.com/vuejs/composition-api) примерно в ноябре 2019 года. С тех пор начальные принципы остались неизменными, но Pinia работает как для Vue 2, так и для Vue 3 **и не требует использования composition API**. API одинаков для обоих, за исключением _установки_ и _SSR_, и эта документация предназначена для Vue 3 **с примечаниями о Vue 2**, когда это необходимо, чтобы ее могли читать пользователи Vue 2 и Vue 3!

## Почему я должен использовать Pinia?

Pinia - это библиотека хранилища для Vue, она позволяет вам совместно использовать состояние между компонентами/страницами. Если вы знакомы с Composition API, вы можете подумать, что уже можете поделиться глобальным состоянием с помощью простого `export const state = reactive({})`. Это верно для одностраничных приложений, но **подвергает ваше приложение [уязвимостям безопасности](https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution)**, если оно рендерится на стороне сервера. Но даже в небольших одностраничных приложениях вы получите много пользы от использования Pinia:

- Поддержка Devtools
  - Временная шкала для отслеживания действий, мутаций
  - Хранилища появляются в компонентах, где они используются
  - Путешествие во времени и облегчение отладки
- Горячая замена модулей
  - Изменяйте свои хранилища состоянием без перезагрузки страницы
  - Сохраняйте любое существующее состояние во время разработки
- Плагины: расширяйте возможности Pinia с помощью плагинов
- Поддержка TypeScript или **автозавершение** для пользователей JS
- Поддержка рендеринга на стороне сервера

<VueMasteryLogoLink for="pinia-cheat-sheet">
</VueMasteryLogoLink>

## Базовый пример

Вот как выглядит использование Pinia с точки зрения API (обязательно ознакомьтесь с [Начало работы](./getting-started.md) для получения полных инструкций). Вы начинаете с создания магазина:

```js
// stores/counter.js
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
    state: () => {
        return { count: 0 }
    },
    // можно также определить как
    // state: () => ({ count: 0 })
    actions: {
        increment() {
            this.count++
        },
    },
})
```

А затем вы _используете_ его в компоненте:

```vue
<script setup>
import { useCounterStore } from '@/stores/counter'

const counter = useCounterStore()

counter.count++
// с autocompletion ✨
counter.$patch({ count: counter.count + 1 })
// или использовать вместо этого action
counter.increment()
</script>

<template>
    <!-- Получите доступ к состоянию непосредственно из store -->
    <div>Текущее количество: {{ counter.count }}</div>
</template>
```

Вы даже можете использовать функцию (аналогичную компоненту `setup()`) для определения хранилища для более продвинутых вариантов использования:

```js
export const useCounterStore = defineStore('counter', () => {
    const count = ref(0)
    function increment() {
        count.value++
    }

    return { count, increment }
})
```

Если вы все еще не знакомы с `setup()` и Composition API, не волнуйтесь, Pinia также поддерживает аналогичный набор [_map helpers_, таких как Vuex](https://vuex.vuejs.org/guide/state.html#the-mapstate-helper). Вы определяете хранилища таким же образом, но затем используете `mapstor()`, `mapState()` или `mapActions()`:

```js {22,24,28}
const useCounterStore = defineStore('counter', {
    state: () => ({ count: 0 }),
    getters: {
        double: (state) => state.count * 2,
    },
    actions: {
        increment() {
            this.count++
        },
    },
})

const useUserStore = defineStore('user', {
    // ...
})

export default defineComponent({
    computed: {
        // другие вычисляемые свойства
        // ...
        // предоставляет доступ к this.counterStore и this.UserStore
        ...mapStores(useCounterStore, useUserStore),
        // предоставляет доступ на чтение к this.count и this.double
        ...mapState(useCounterStore, ['count', 'double']),
    },
    methods: {
        // предоставляет доступ к this.increment()
        ...mapActions(useCounterStore, ['increment']),
    },
})
```

Вы найдете более подробную информацию о каждом _map helper_ в основных концепциях.

## Почему _Pinia_

Pinia (произносится `/piːnjʌ/`, как "peenya" по-английски) - самое близкое слово к _piña_ (_pineapple_ по-испански), которое является допустимым названием пакета. На самом деле ананас - это группа отдельных цветков, которые соединяются вместе, образуя множество плодов. Подобно магазинам, каждый из них рождается индивидуально, но в конце все они соединяются. Это также восхитительный тропический фрукт, произрастающий в Южной Америке.

## Более реалистичный пример

Вот более полный пример API, который вы будете использовать с Pinia **с типами даже в JavaScript**. Для некоторых людей этого может быть достаточно, чтобы начать, не читая дальше, но мы все равно рекомендуем проверить остальную документацию или даже пропустить этот пример и вернуться, как только вы ознакомитесь со всеми основными концепциями.

```js
import { defineStore } from 'pinia'

export const useTodos = defineStore('todos', {
    state: () => ({
        /** @type {{ text: string, id: number, isFinished: boolean }[]} */
        todos: [],
        /** @type {'all' | 'finished' | 'unfinished'} */
        filter: 'all',
        // type will be automatically inferred to number
        nextId: 0,
    }),
    getters: {
        finishedTodos(state) {
            // autocompletion! ✨
            return state.todos.filter((todo) => todo.isFinished)
        },
        unfinishedTodos(state) {
            return state.todos.filter((todo) => !todo.isFinished)
        },
        /**
         * @returns {{ text: string, id: number, isFinished: boolean }[]}
         */
        filteredTodos(state) {
            if (this.filter === 'finished') {
                // вызывать другие геттеры с помощью autocompletion ✨
                return this.finishedTodos
            } else if (this.filter === 'unfinished') {
                return this.unfinishedTodos
            }
            return this.todos
        },
    },
    actions: {
        // любое количество аргументов, возвращает promise или нет
        addTodo(text) {
            // вы можете напрямую изменять состояние
            this.todos.push({ text, id: this.nextId++, isFinished: false })
        },
    },
})
```

## Сравнение с Vuex

Pinia начиналась как исследование того, как может выглядеть следующая итерация Vuex, вобрав в себя многие идеи из обсуждений основной команды Vuex 5. В конце концов, мы поняли, что Pinia уже реализует большую часть того, что мы хотели видеть в Vuex 5, и решили сделать ее новой рекомендацией.

По сравнению с Vuex, Pinia предоставляет более простой API с меньшим количеством церемоний, предлагает API в стиле Composition-API, и, что самое важное, имеет надежную поддержку вывода типов при использовании TypeScript.

### RFCs

Изначально Pinia не проходила через процесс RFC. Я тестировал идеи, основываясь на своем опыте разработки приложений, чтении чужого кода, работе с клиентами, использующими Pinia, и ответах на вопросы в Discord.
Это позволило мне предложить решение, которое работает и адаптировано к различным случаям и размерам приложений. Я часто публиковался и заставлял библиотеку развиваться, сохраняя неизменным ее основной API.

Теперь, когда Pinia стала решением по умолчанию для управления состоянием, она подвергается тому же RFC-процессу, что и другие основные библиотеки в экосистеме Vue, а ее API вошел в стабильное состояние.

### Сравнение с Vuex 3.x/4.x

> Vuex 3.x - это Vuex для Vue 2, а Vuex 4.x - для Vue 3.

Pinia API сильно отличается от Vuex ≤4, а именно:

- _мутаций_ больше не существует. Они часто воспринимались как **_экстремально_ многословные**. Изначально они привносили интеграцию с devtools, но теперь это больше не проблема.
- Нет необходимости создавать собственные сложные обертки для поддержки TypeScript, все типизировано, а API разработан таким образом, чтобы максимально использовать вывод типов TS.
- Больше не нужно вводить магические строки, импортируйте функции, вызывайте их, наслаждайтесь автозавершением!
- Нет необходимости динамически добавлять хранилища, они все динамические по умолчанию, и вы даже не заметите. Обратите внимание, что вы все еще можете вручную использовать хранилище, чтобы зарегистрировать его, когда захотите, но поскольку это происходит автоматически, вам не нужно об этом беспокоиться.
- Больше никакой вложенной структуризации _модулей_. Вы все еще можете вложить хранилища неявно, импортируя и _используя_ одно хранилище внутри другого, но Pinia предлагает плоскую структуризацию по дизайну, сохраняя при этом возможность перекрестной композиции между хранилищами. **Вы даже можете иметь круговые зависимости между хранилищами**.
- Никаких _размещенных по именам модулей_. Учитывая плоскую архитектуру хранилищ, "распределение имен" хранилищ является неотъемлемой частью того, как они определяются, и можно сказать, что все хранилища распределены по именам.

Более подробные инструкции по преобразованию существующего проекта Vuex ≤4 для использования Pinia см. в [Руководстве по миграции с Vuex](./cookbook/migration-vuex.md).
